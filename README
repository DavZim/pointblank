----------
pointblank
----------

Tables can often be trustworthy. All the data seems to be
there and we may feel we can count on these tables to deliver
us the info we need. Still, sometimes, the tables we trust
are hiding things from us. Malformed strings, numbers we don't
expect, missing values that ought not to be missing. These
abberations can be hiding almost in plain sight. Such
inconsistencies can be downright insidious, making us ask
ourselves, "can we really trust any table?"

Sure, we can sit down with a table during a long interrogation
session and rough it up with a little SQL. Problem is, we have 
lots of tables, and we usually have a lot of columns in every 
one of these tables. Makes for long hours with many suspect 
tables...

We need a tool like pointblank. It lets us get up close with
tables and unleash a fury of validation checks. Are some tables
remote? That's no problem, we'll interrogate them from afar. 
In essence, your Redshift tables can get the same line of 
questioning as your local data frames or those innocent-looking
tibbles. Trust me, they'll start to talk and then they'll surely
reveal what they're hiding after a pointblank session.

You don't have to type up a long report either, pointblank 
will take care of the paperwork. At the very least, you'll get
a tidy data frame of the essentials. With a little planning, a
very informative sitrep can be regularly produced.

------------- CODE PORTION FOLLOWS -------------

# For a simple example with local tables, ensure that
# the development version of `pointblank` is installed via

devtools::install_github("rich-iannone/pointblank")

# Then load the necessary packages

library(tibble)
library(pointblank)
library(magrittr)

# To illustrate a basic use of pointblank,
# make a simple local table
tbl_1 <-
  tribble(
    ~a, ~b,   ~c,
    1,   6,   "h2adb",
    2,   7,   "h2spb",
    3,   8,   "h2df",
    4,   9,   "d3jwb",
    5,  10,   "h2esf"
  )

# Make another local table
tbl_2 <-
  tribble(
    ~d,   ~e,  ~f,
    "a",   0,  32,
    "b",   0,  31,
    "a",   1,  30,
    "a",   1,  32,
    "ae", -1,  39
  )

# Now:
#  (1) - create an agent with `create_agent()`
#  (2) - focus on `tbl_1` using `focus_on()`
#  (3) - add step: are vals in col `a` > 0?
#  (4) - add step: are vals in `col(a) + col(b)` >= 7?
#  (5) - add step: are column vals in `b` <= 10?
#  (6) - add step: do all `c` vals match regex `h2.*`?
#  (7) - add step: are all `c` substrings part of a set?
#  (8) - focus on `tbl_2` using `focus_on()`
#  (9) - add step: are all values in `d` part of a set?
# (10) - add step: are all `d` values not part of a set?
# (11) - add step: are column vals in `e` >= 0?
# (12) - add step: are all `f` values NULL/NA?
# (13) - add step: are all `f` values not NULL/NA?
# (14) - finally, perform all checks with `interrogate()`
agent <- 
  create_agent() %>%             # (1)
  focus_on(
    tbl_name = "tbl_1") %>%      # (2)
  col_vals_gt(
    column = "a",
    value = 0) %>%               # (3)
  col_vals_gte(
    column = "a + b",
    value = 7) %>%               # (4)
  col_vals_lte(
    column = "b",
    value = 10) %>%              # (5)
  col_vals_regex(
    column = "c",
    regex = "h2.*") %>%          # (6)
  col_vals_in_set(
    column = "substr(c, 0, 2)",
    set = c("h2", "d3")) %>%     # (7)
  focus_on(
    tbl_name = "tbl_2") %>%      # (8)
  col_vals_in_set(
    column = "d",
    set = c("a", "b")) %>%       # (9)
  col_vals_not_in_set(
    column = "d",
    set = c("a", "b")) %>%       # (10)
  col_vals_gte(
    column = "e",
    value = 0) %>%               # (11)
  col_vals_null(
    column = "f") %>%            # (12)
  col_vals_not_null(
    column = "d") %>%            # (13)
  interrogate()                  # (14)

# Get a summary of the interrogations, just the
# basics (more info is available within `agent`)
get_summary(agent)
#> # A tibble: 9 Ã— 11
#>   tbl_name db_type      assertion_type  
#>      <chr>   <chr>               <chr>  
#> 1    tbl_1   local        col_vals_gte  
#> 2    tbl_1   local        col_vals_lte  
#> 3    tbl_1   local      col_vals_regex  
#> 4    tbl_1   local     col_vals_in_set  
#> 5    tbl_2   local     col_vals_in_set  
#> 6    tbl_2   local col_vals_not_in_set  
#> 7    tbl_2   local        col_vals_gte  
#> 8    tbl_2   local       col_vals_null  
#> 9    tbl_2   local   col_vals_not_null  

#>            column value        set regex
#>             <chr> <dbl>     <list> <chr>
#> 1           a + b     7     <NULL>  <NA>
#> 2               b    10     <NULL>  <NA>
#> 3               c    NA     <NULL>  h2.*
#> 4 substr(c, 0, 2)    NA <list [1]>  <NA>
#> 5               d    NA <list [1]>  <NA>
#> 6               d    NA <list [1]>  <NA>
#> 7               e     0     <NULL>  <NA>
#> 8               f    NA     <NULL>  <NA>
#> 9               d    NA     <NULL>  <NA>
   
#>   all_passed     n n_passed n_failed
#>        <lgl> <int>    <int>    <int>
#> 1       TRUE     5        5        0
#> 2       TRUE     5        5        0
#> 3      FALSE     5        4        1
#> 4       TRUE     5        5        0
#> 5      FALSE     5        4        1
#> 6      FALSE     5        1        4
#> 7      FALSE     5        4        1
#> 8      FALSE     5        1        4
#> 9       TRUE     5        5        0

------------- CODE PORTION FINISHED -------------

As can be seen, pointblank already proves to be an
effective tool in finding out whether your local tables
have unexpected values. More examples will follow with
tables in remote databases.
